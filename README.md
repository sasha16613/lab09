# Лабораторная работа 9

## Цель
Цель работы - получить навыки работы с динамическим полиморфизмом.

## Теоретическая часть
**Полиморфизм** - способность объектов различных типов обладать одним и тем же публичным контрактом.

Полиморфизм может быть статическим или динамическим. В статическом полиморфизме выбор вызываемой функции определяется **во время компиляции** программы. В динамическом полиморфизме выбор определяется **во время выполнения** программы.

### Статический полиморфизм
К статическому полиморфизму можно причислить и обычные переопределения функций и операторов.
Но рассмотрим другой пример статического полиморфизма основанный на шаблоннах.

Допустим, необходимо написать функцию, которая сериализует объекты разных типов.

```cpp
template <class T>
void Serialize(const T& obj, std::vector<byte>& out_data) {
  obj.Serialize(out_data);
}
```

Есть два класса:
```cpp
struct NetStat {
  int count;
  std::string name_;
  Serialize(std::vector<byte>& out) {
    // ...
  }
};

struct Student {
  std::string name_;
  std::vector<int> ratings_;
  Serialize(std::vector<byte>& out) {
    // ...
  }
};
```

Объекты обоих этих классов, можно сериализовать с помощью шаблонной фукнции `Serialize`.
А какой из двух методов `NetStat::Serialize` или `Student::Serialize` будет вызван зависит от аргумента фукнции `Serialize`.

```cpp
std::vector<byte> data;
Student s;
Serialize(s, data);

NetStat net;
Serialize(net, data);
```

Компилятор на этапе компиляции определяет, какой метод необходимо вызвать.

##### Преимущества
* Скорость выполнения скомпилированной программы. Так как какой метод вызвать определяется во время компиляции программы, программа во время выполнения не тратил лишнее время.
* Чтобы использовать статический полиморфизм классы не должны быть наследниками одного базового класса.
* Более надежный в плане безопасности типов.

### Динамический полиморфизм
Динамический полиморфизм тесно связан с наследованием, при чем только с открытым (public) наследованием. _Предполагается, что студент знаком с базовыми понятиями наследования. Напомним, что в случае открытого наследования возможно присваивать указатель (или ссылку) дочерного класса указателю базового класса:_
```cpp
struct Base { };
struct Derived : public Base {};
Base* ptr = new Derived();

Derived obj;
Base& ref = obj;
```


Рассмотрим следующий пример. Предположим, что мы пишем RTS игру, и хотим реализовать класс управления армией - множеством персонажей различного типа.
Логично, что мы хотим реализовать этот класс как можно проще. И решающее требование - состав армией должен выбираться пользователем, т.е во время выполнения программы.

Требования сформулированны, подумаем как мог бы выглядить такой класс. Т.к. армия должна содержать множество юнитов, то добавим массив юнитов в класс.

```cpp
class Army {
  std::vector<Unit*> units_;

 public:
  void AddUnit(Unit* unit) {
    units_.push_back(unit);
  }
};
```

Любая армия должна быть способной аттаковать, поэтому добавим методы `Attack`. Мы хотим реализовать эффективную и вымурштрованную армию, в которой каждый боец знает (так не бывает, конечно же), как ему поступать и выполнять действия он должен в соответсвии со своим классом, поэтому просто вызовем соответсвующий метод.

```cpp
class Army {
  // ...
  void Attack() {
    for (Unit* u : units_) {
      u->Attack();
    }
  }
```

Теперь рассмотрим классы бойцов.
```cpp
struct Unit {
  void Attack() {
    std::cout << "Unit::Attack" << std::endl;
  }
};
struct Knight : public Unit {
  void Attack() {
    std::cout << "Knight::Attack" << std::endl;
  }
};
struct Warrior : public Unit {
  void Attack() {
    std::cout << "Warrior::Attack" << std::endl;
  }
};
```

Добавим бойцов в армию и аттакуем ею:
```cpp
Army army;
army.AddUnit(new Knight());
army.AddUnit(new Warrior());
army.AddUnit(new Warrior());
army.AddUnit(new Knight());

army.Attack();
```

В итоге получим следующий вывод:
```cpp
"Unit::Attack"
"Unit::Attack"
"Unit::Attack"
"Unit::Attack"
```

Каждый юнит аттаковал не в соответствии со своим реальным типом, а в соответствии с типом переменной, у которой вызвался метод. Чтобы избежать такого поведения, необходимо использовать виртуальный метод. Для этого использовуем ключевое слово `virtual` в базовом классе у метода `Attack`:
```cpp
struct Unit {
  virtual void Attack() {
    std::cout << "Unit::Attack" << std::endl;
  }
  virtual ~Unit() = default;
};
struct Knight : public Unit {
  void Attack() override {
    std::cout << "Knight::Attack" << std::endl;
  }
};
struct Warrior : public Unit {
  void Attack() override {
    std::cout << "Warrior::Attack" << std::endl;
  }
};
```

Теперь если скомпилировать программу и запустить, то вывод будет другим:
```cpp
"Knight::Attack"
"Warrior::Attack"
"Warrior::Attack"
"Knight::Attack"
```

Таким образом были вызваны методы соответсвующих **дочерних** классов, а не метод **базового** класса.

Использование виртуального метода позволяет программе вызывать метод того класса, которым является объект, а не метод класса, тип которого используется для вызова класса.

Точечно рассмотрим эффект от ключевого слова `virtual`.

Рассмотрим код в случае, если метод `Attack` **НЕ** виртуальный:
```cpp
Knight k;
k.Attack();
Unit& u = k;
u.Attack();
```
Тогда вывод программы будет:
```cpp
"Knight::Attack"
"Unit::Attack"
```
Т.е из-за того, что переменная `u` ссылка типа `Unit&`, не смотря на то, что ссылка связана с объектом типа `Knight` - вызывается метод класса `Unit`!


Если рассмотреть случай, когда метод `Attack` **является** виртуальным:
```cpp
Knight k;
k.Attack();
Unit& u = k;
u.Attack();
```
Тогда вывод программы будет:
```cpp
"Knight::Attack"
"Knight::Attack"
```
Таким образов тип переменной `u` не влияет на вызываемый метод, и будет вызван метод **в соответствии с типом объекта**, а не типом переменной!

Такое поведение называют динамическим полиморфизмом - вызов метода на основании типа хранимого **объекта**, а не на основании типа объявленной переменной.

#### Ключевое слово `virtual`
Смысл ключевого слова `virtual` объявняется выше. Это ключевое слово необходимо для реализации динамического полиморфизма. Стоит упоминуть, что любой переопределенный виртуальный метод базового класса является в дочернем классе тоже является виртуальным.

#### Ключевое слово `override`
Ключевое слово `override` полезно добавлять всякий раз, когда переопределяете метод базового класса, хотя оно не обязательно.

Когда вы объявляете `override`, вы тем самым говорите компилятору, что вы намерены переопределить **виртуальный** метод базового класса. В этом случае компилятор будет проводить следующие проверки:
* метод с точно такой же сигнатурой существует в базовом классе
* этот метод объявлен в базовом классе как виртуальный.

#### Ключевое слово `final`
Иногда требуется запретить наследовать ваш класс или запретить переопределять виртуальную функцию. Для этого можно использовать модификатор `final`.
```cpp
class Student final {
  // ...
};
```

```cpp
class A {
 public:
	virtual std::string name() { return "A"; }
};

class B : public A {
 public:
	std::string name() override final { return "B"; }
};
```

### Абстрактные классы
Абстрактный метод (pure virtual method) — метод класса, реализация для которого отсутствует. Класс, содержащий абстрактные методы, также принято называть абстрактным.

Например, метод `Attack` можно объявить абстрактным, каждый наследник этого класса должен переопределить этот метод.
```cpp
struct Unit {
  virtual void Attack() = 0;
};
```

### Виртуальный деструктор
Вернемся к армии и вспомним код использования этим классом

```cpp
Army army;
army.AddUnit(new Knight());
army.AddUnit(new Warrior());
army.AddUnit(new Warrior());
army.AddUnit(new Knight());
```

Чтобы не было утечек памяти, мы должны реализовать деструктор класса:
```cpp
class Army {
  // ...
  ~Army() {
    for(Unit* u : units_) {
      delete u; // Вызывается деструктор
    }
  }
  // ...
};
```
В примере выше вызывается деструктор, но дектруктор какого типа будет вызван? Здесь логика ничем не отличается от обычных методов:
* если у декструктора есть модификатор `virtual`, то будет вызван деструктор нужного класса;
* если у декструктора нет модификатора `virtual`, то будет вызван деструктор базового класса, что приведет к ошибкам разного рода.

**Если вы объявляете хотя бы одну виртуальную функцию в классе, объявите виртуальным и деструктор!**
```cpp
struct Unit {
  virtual void Attack() = 0;
  virtual ~Unit() = default;
};
```

### Ограничения
Пока не завершился конструктор класса, класс является не до конца сконфигурированным.

Поэтому при вызове виртуальной функции внутри конструктора, нельзя быть уверенным какой именно метод (базового класса или дочернего) будет вызван. В следствии этого, не вызывайте виртуальные фукнции внутри конструктора. Такое же ограничение действует и в деструкторе.

**НЕ вызывайте виртуальные методы в конструкторе и деструкторе класса**.

## Таблица виртуальных функций
Чтобы лучше понимать динамический полиморфизм, можно углубиться в то, как именно реализован механизм поиска виртуальной функций во время выполнения программы.

В С++ поиск виртуальной функции основан на таблице виртуальных фукнций. Предполагается самостоятельно освоить эту тему (например, https://ravesli.com/urok-167-virtualnye-tablitsy/) или прослушать данную тему на лекции.

## Задание
Создать библиотеку для расчета сопротивления электрической цепи переменного тока.

Библиотека должна расчитывать сопротивления:
* последовательных соединений элементов (`SequentialConnections`);
* параллельных соединений (`ParallelConnections`);
* композицию последовательных и параллельных соединений.

В качестве базовых элементов должна быть возможность использовать:
* резисторы (`Resistor`);
* конденсаторы (`Capacitor`);
* инструкции (`Inductor`).

Реализовать модульные тесты, используя Gtest.

### Пример использования библиотеки
```cc
SequentialConnections conn;

conn.AddElement(new Resistor(1f));
conn.AddElement(new Resistor(2f));
conn.AddElement(new Capacitor(0.01f));
ParallelConnections * parallel = new ParallelConnections();
parallel->AddElement(new Resistor(1f));
parallel->AddElement(new Capacitor(0.01f));
parallel->AddElement(new Inductor(3f));
conn.AddElement(parallel);
conn.AddElement(new Resistor(1f));

Power power(12, 1000); // 12 volts, 1000 Hz, sin signal
float resistance = conn.CalculateResistance(power);
```

## Рекомендации по выполнению
Все объекты следует наследовать от абстрактного класса
```cc
class Element {
 public:
  virtual float CalculateResistance(const Power&) const;
};
```

Класс `Power` представляет источник переменного тока. Частота передается в
конструктор класса `Power` и используется для расчета сопротивлений,
конденсаторов и инструкций.

Конструктор класса `Resistor` принимает значение своего сопротивления в Омах.

Конструктор класса `Capacitor` принимает значение своей емкости.

Конструктор класса `Inductor` принимает значение своей индуктивности.

Классы `SequentialConnections` и `ParallelConnections` так же следует
наследовать от класса `Element`. Так же, эти классы принимают аргумент метода
`AddElement` **во владение**, т.е. отвечают за его удаление.

### Современный C++
Чтобы избежать лишних действий в деструкторах классов `SequentialConnections` и
`ParallelConnections`, рекомендуем использовать `std::unique_ptr` - класс
уникального владения объектом. Т.е. `std::unique_ptr` отвечает за удаление
объекта, на который он указывает.

Если использовать `std::unique_ptr`, то код изменится следующим образом:
```cc
SequentialConnections conn;

conn.AddElement(std::make_unique<Resistor>(1f));
conn.AddElement(std::make_unique<Resistor>(2f));
conn.AddElement(std::make_unique<Capacitor>(0.01f));
auto parallel = std::make_unique<ParallelConnections>();
parallel->AddElement(std::make_unique<Resistor>(1f));
parallel->AddElement(std::make_unique<Capacitor>(0.01f));
parallel->AddElement(std::make_unique<Inductor>(3f));
conn.AddElement(std::move(parallel));
conn.AddElement(std::make_unique<Resistor>(1f));

Power power(12, 1000); // 12 volts, 1000 Hz, sin signal
float resistance = conn.CalculateResistance(power);
```

Пример добавления `std::unique_ptr` в контейнер `std::set`:
```cc
struct Example {

  void AddToSet(std::unique_ptr<Element> element) {
    set.insert(std::move(element));
  }
  std::set<std::unique_ptr<Element>> elements_;
};

Example e;
e.AddToSet(std::make_unique<Resistor>(12f));
auto parallel = std::make_unique<ParallelConnections>();
e.AddToSet(std::move(parallel));
```

## Необязательная часть задания

### Современный C++ часть 2
Определите пользовательские литералы для  констант микро- и нанофарад, а также микро- и наногенри.

**Пример**
```cc
parallel->AddElement(std::make_unique<Inductor>(3mH)); // создает Inductor в 3 микрогенри
parallel->AddElement(std::make_unique<Inductor>(3nH)); // создает Inductor в 3 наногенри
```

Подробности читайте в статье - https://habr.com/ru/post/140357/

### Для любителей "функционального программирования"
Реализуйте другой интерфейс для работы с элементами:
```cc
SequentialConnections conn = Resistor(330) &&
            Capacitor(220nf) &&
            Inductor(0.1) &&
            ( Resistor(220) || Capacitor(470nf) || Inductor(3mH) ) &&
            Resistor(100);
auto power = Power(12, 50); // 12 volts, 50 Hz, sin signal
auto resistance = conn.CalculateResistance(power); // или auto resistance = conn ~ power;
// resistance is complex! Active and reactive parts.
```
Т.е. оператор `||` добавляет элемент параллельно предыдущему, а `&&` создает последовательное соединение.
